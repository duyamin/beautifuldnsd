#!/usr/bin/env python3

import sys
import os
import logging
import asyncio
import socket
import ipaddress
from functools import partial
import struct

import dnslib

logger = logging.getLogger('fixeddnsd')

def config_logging(level=logging.WARN, style=None):
  '''
  ``style``: terminal or plain
  '''
  if style is None:
    if os.isatty(sys.stderr.fileno()):
      style = 'terminal'
    else:
      style = 'plain'

  if style == 'plain':
    logging.basicConfig(
      level=level,
      format='%(levelname)s: %(message)s',
    )
  elif style == 'terminal':
    try:
      from nicelogger import enable_pretty_logging
      enable_pretty_logging(level)
    except ImportError:
      logging.basicConfig(
        level=level,
        format='%(asctime) s%(levelname)s: %(message)s',
        datefmt='[%Y-%m-%d %H:%M:%S]',
      )
  else:
    raise ValueError('bad logging style %r' % style)

class UDPDNSServer:
  sock = None

  def __init__(self, address, *, loop=None):
    self.sock = s = socket.socket(
      ip_family(address[0]), socket.SOCK_DGRAM)
    s.setblocking(False)
    s.bind(address)

    self.loop = loop = loop or asyncio.get_event_loop()
    loop.add_reader(s.fileno(), self.on_request)

  def on_request(self):
    co = self.handle_request()
    asyncio.Task(co, loop=self.loop)

  @asyncio.coroutine
  def handle_request(self):
    s = self.sock
    try:
      data, addr = s.recvfrom(2048)
    except BlockingIOError:
      return

    dns = dnslib.DNSRecord.parse(data)
    logger.info('%r request record %s of %s', addr,
                dnslib.QTYPE[dns.q.qtype], dns.q.qname)
    # TODO
    ans = yield from config['clients'][0].query(data)
    s.sendto(ans, addr)

  def close(self):
    if self.sock:
      self.loop.remove_reader(self.sock.fileno())
      self.sock.close()
      self.sock = None

  def __del__(self):
    self.close()

class ConnectionClosedError(ConnectionError):
  pass

def ip_family(ip):
  a = ipaddress.ip_address(ip)
  if a.version == 4:
    return socket.AF_INET
  elif a.version == 6:
    return socket.AF_INET6
  else:
    raise ValueError('unsupport IP address: %r', a)

@asyncio.coroutine
def recv_exactly(sock, n, *, loop=None):
  loop = loop or asyncio.get_event_loop()
  data = b''
  left = n
  while left:
    d = yield from loop.sock_recv(sock, left)
    if not d:
      raise ConnectionClosedError
    data += d
    left -= len(d)
  return data

class DNSClient:
  sock = None
  connecting = None

  def __init__(self, address, type=socket.SOCK_DGRAM,
               *, loop=None):
    self.loop = loop or asyncio.get_event_loop()
    self.address = address
    self.type = type
    self.connect()

  def connect(self):
    self.close()
    self.sock = socket.socket(ip_family(self.address[0]), self.type)
    self.sock.setblocking(False)
    self.connecting = self.loop.sock_connect(self.sock, self.address)
    self.connecting.add_done_callback(self.connected)

  def connected(self, fu):
    fu.result()
    self.connecting = None
    logger.info('%s: just connected', self)

  def __repr__(self):
    return '<%s [%s]: %s>' % (
      self.__class__.__name__,
      self.format_address(),
      'connecting' if self.connecting else 'connected',
    )

  def format_address(self):
    return '%s:%s:%d' % (
      'TCP' if self.type is socket.SOCK_STREAM else 'UDP',
      self.address[0], self.address[1])

  def close(self):
    if self.sock:
      self.sock.close()
      self.sock = None

  def __del__(self):
    self.close()

  @asyncio.coroutine
  def query(self, request, filter=None):
    if self.connecting:
      yield from self.connecting
      self.connecting = None

    # TODO: timeout handling
    type = self.type
    loop = self.loop
    s = self.sock

    if type is socket.SOCK_STREAM:
      data = struct.pack('!H', len(request)) + request
    else:
      data = request

    try:
      yield from loop.sock_sendall(s, data)
      while True:
        if type is socket.SOCK_STREAM:
          header = yield from recv_exactly(s, 2)
          n = struct.unpack('!H', header)[0]
          ans = yield from recv_exactly(s, n)
        else:
          ans = yield from loop.sock_recv(s, 2048)
        if filter and filter(ans):
          continue
        else:
          break
    except ConnectionError:
      logger.warn('%s: connection error, reconnecting', self, exc_info=True)
      self.connect()
      ans = yield from self.query(request, filter)

    return ans

def main():
  loop = asyncio.get_event_loop()
  servers = [UDPDNSServer(s) for s in config['servers']]
  logging.info('serving on %r.', config['servers'])
  loop.run_forever()

if __name__ == '__main__':
  logging.getLogger('asyncio').setLevel(logging.WARN)
  config_logging(level=logging.DEBUG)
  config = {
    'servers': [('127.0.0.1', 5353), ('::1', 5353)],
    # 'clients': [DNSClient(('127.0.0.1', 53))],
    'clients': [DNSClient(('127.0.0.1', 53), socket.SOCK_STREAM)],
  }
  try:
    main()
  except KeyboardInterrupt:
    pass
