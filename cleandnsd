#!/usr/bin/env python3

import sys
import os
import base64
import logging
import asyncio
import socket
import ipaddress
from itertools import chain
import struct
import time
import signal

import dnslib

from stats import Stat

logger = logging.getLogger('cleandnsd')
# TODO: handle truncated reply
SERVFAIL = dnslib.RCODE.SERVFAIL

class SwitchServer(Exception): pass

def config_logging(level=logging.WARN, style=None):
  '''
  ``style``: terminal or plain
  '''
  if style is None:
    if os.isatty(sys.stderr.fileno()):
      style = 'terminal'
    else:
      style = 'plain'

  if style == 'plain':
    logging.basicConfig(
      level=level,
      format='%(levelname)s: %(message)s',
    )
  elif style == 'terminal':
    try:
      from nicelogger import enable_pretty_logging
      enable_pretty_logging(level)
    except ImportError:
      logging.basicConfig(
        level=level,
        format='%(asctime) s%(levelname)s: %(message)s',
        datefmt='[%Y-%m-%d %H:%M:%S]',
      )
  else:
    raise ValueError('bad logging style %r' % style)

def ip_family(ip):
  a = ipaddress.ip_address(ip)
  if a.version == 4:
    return socket.AF_INET
  elif a.version == 6:
    return socket.AF_INET6
  else:
    raise ValueError('unsupport IP address: %r', a)

@asyncio.coroutine
def recv_exactly(sock, n, *, loop=None):
  loop = loop or asyncio.get_event_loop()
  data = b''
  left = n
  while left:
    d = yield from loop.sock_recv(sock, left)
    if not d:
      raise ConnectionClosedError
    data += d
    left -= len(d)
  return data

def reply_with(request, rcode):
  ans = request.reply()
  ans.header.rcode = rcode
  return ans.pack()

def filter_badip(dns):
  if isinstance(dns.a.rdata, dnslib.A) and \
     str(dns.a.rdata) in config['filtered_ips']:
    return 'skip'

def filter_badip_switch(dns):
  r = filter_badip(dns)
  if r == 'skip':
    r = 'switch'
  return r

def is_bogus_nxdomain(dns):
  if isinstance(dns.a.rdata, dnslib.A) and \
     str(dns.a.rdata) in config['bogus_ips']:
    return True

@asyncio.coroutine
def get_bogus_nxdomain(interval):
  while True:
    interval_ = interval
    r = base64.b64encode(os.urandom(24)).decode('ascii')
    nxdomain = r.replace('/', '').replace('+', '') + '.com'
    req = dnslib.DNSRecord.question(nxdomain)
    for client in config['primary_upstreams']:
      try:
        ans, parsed = yield from client.query(req)
      except Exception as e:
        logger.debug('%r while discovering bogus IP. Will try later.', e)
        interval_ = 2
        continue

      if parsed.header.rcode == SERVFAIL:
        logger.debug('SERVFAIL while discovering bogus IP. Will try later.')
        interval_ = 2
        continue
      if isinstance(parsed.a.rdata, dnslib.A):
        ip = str(parsed.a.rdata)
        logger.info('got bogus nxdomain: %s', ip)
        config['bogus_ips'].add(ip)
      else:
        logger.debug('no bogus nxdomain found:\n%s', parsed)
    yield from asyncio.sleep(interval_)

class ConnectionClosedError(ConnectionError):
  pass

class DNSCommon:
  sock = None

  @property
  def _stat(self):
    if not hasattr(self, '_stat_'):
      self._stat_ = Stat()
    return self._stat_

  def __repr__(self):
    return '<%s [%s]>' % (
      self.__class__.__name__,
      self.format_address(),
    )

  def format_address(self):
    return '%s:%s:%d' % (
      'TCP' if self.type is socket.SOCK_STREAM else 'UDP',
      self.address[0], self.address[1])

  def __del__(self):
    self.close()

  def close(self):
    if self.sock:
      self.loop.remove_reader(self.sock.fileno())
      self.sock.close()
      self.sock = None

  def record_time(self, t):
    self._stat.add(t * 1000)

class UDPDNSServer(DNSCommon):
  sock = None
  type = socket.SOCK_DGRAM

  def __init__(self, address,
               primary_upstreams, secondary_upstreams,
               *, loop=None, concurrent_delay = None,
               primary_timeout = 3, secondary_timeout = 3):
    self.address = address
    self.loop = loop = loop or asyncio.get_event_loop()
    self.primary_upstreams = primary_upstreams
    self.secondary_upstreams = secondary_upstreams
    self.concurrent_delay = concurrent_delay
    for c in primary_upstreams:
      c.filters = (filter_badip_switch,)
      c.timeout = primary_timeout
    for c in secondary_upstreams:
      c.filters = (filter_badip,)
      c.timeout = secondary_timeout

    self.sock = s = socket.socket(
      ip_family(address[0]), socket.SOCK_DGRAM)
    s.setblocking(False)
    s.bind(address)

    loop.add_reader(s.fileno(), self.on_request)

  def on_request(self):
    co = self.handle_request()
    fu = asyncio.async(co, loop=self.loop)
    fu.add_done_callback(lambda fu: fu.result())

  @asyncio.coroutine
  def handle_request(self):
    s = self.sock
    try:
      data, addr = s.recvfrom(2048)
    except BlockingIOError:
      return

    start = time.time()
    request = dnslib.DNSRecord.parse(data)
    logger.info('%r request record %s of %s', addr,
                dnslib.QTYPE[request.q.qtype], request.q.qname)

    no_more = False
    failed = False
    no_primary = False
    concurrent_delay = self.concurrent_delay
    if concurrent_delay is None:
      # try one by one
      it = chain(self.primary_upstreams, self.secondary_upstreams)
    else:
      # try crossingly
      it = chain.from_iterable(
        zip(self.primary_upstreams, self.secondary_upstreams))
    futures = []
    while True:
      try:
        while True:
          server = next(it)
          if not no_primary or server not in self.primary_upstreams:
            break
        logger.debug('%s: trying server %s', self, server)
        fu = asyncio.async(server.query(request))
        futures.append(fu)
      except StopIteration:
        concurrent_delay = None
        no_more = True

      done, pending = yield from asyncio.wait(
        futures, loop=self.loop,
        timeout = concurrent_delay,
        return_when=asyncio.FIRST_COMPLETED)

      if no_more and not done:
        failed = True
        break

      got_it = False
      for fu in done:
        futures.remove(fu)
        ex = fu.exception()
        if ex is None:
          ans, parsed = fu.result()
          if parsed.header.rcode == SERVFAIL:
            continue
          got_it = True
          break
        elif isinstance(ex, SwitchServer):
          no_primary = True
        elif isinstance(ex, asyncio.TimeoutError):
          pass
        else:
          raise ex
      if got_it:
        break

    if failed:
      logger.warn('%s: all servers failed to reply', self)
      ans = reply_with(request, SERVFAIL)
    elif is_bogus_nxdomain(parsed):
      logger.warn('%s: bogus nxdomain, sending back nxdomain to %r',
                  self, addr)
      ans = reply_with(request, dnslib.RCODE.NXDOMAIN)
    else:
      logger.debug('%s: sending back DNS answer to %r:\n%s',
                   self, addr, parsed)

    s.sendto(ans, addr)
    end = time.time()
    self.record_time(end - start)

  def log_stat(self):
    logger.info('%s: count/avg/mdev: %d/%.1f/%.1f',
                self,
                self._stat.n, self._stat.avg, self._stat.mdev)

class DNSClient(DNSCommon):
  sock = None
  connecting = None
  filters = ()
  failed_times = 0

  def __new__(cls, address, type=socket.SOCK_DGRAM,
               *, timeout=3, loop=None):
    if type is socket.SOCK_DGRAM:
      C = UDPDNSClient
    else:
      C = TCPDNSClient

    instance = super().__new__(C)
    return instance

  def __init__(self, address, type=socket.SOCK_DGRAM,
               *, timeout=3, loop=None):
    self.loop = loop or asyncio.get_event_loop()
    self.timeout = timeout
    self.address = address
    self.type = type
    self._id_dict = {}
    self.connect()

  def connect(self):
    self.close()
    self.sock = socket.socket(ip_family(self.address[0]), self.type)
    self.sock.setblocking(False)
    self.connecting = self.loop.sock_connect(self.sock, self.address)
    self.connecting.add_done_callback(self.connected)

  def connected(self, fu):
    self.connecting = None
    try:
      fu.result()
    except OSError as e:
      if e.errno == 101: # Network is unreachable
        logger.error('%s: Network is unreachable', self)
        return
      else:
        raise
    logger.info('%s: connected', self)
    self.watch_answers()

  def watch_answers(self):
    self.loop.add_reader(self.sock.fileno(), self.on_answer)

  @asyncio.coroutine
  def query(self, request):
    '''
    may raise asyncio.TimeoutError
    '''
    if self.connecting:
      yield from self.connecting

    data = self.prepare_request(request)
    s = e = time.time()
    do_record = True
    dns = None
    try:
      while True:
        timeleft = s + self.timeout - e
        try:
          yield from self.loop.sock_sendall(self.sock, data)
          ans, dns = yield from asyncio.wait_for(
            self.recv_answer(request),
            timeout = timeleft)
          break
        except ConnectionError:
          logger.warn('%s: connection error, reconnecting', self, exc_info=True)
          self.connect()
        except OSError as e:
          do_record = False
          if e.errno in (22, 89):
            # 22: Invalid argument
            # 89: Destination address required (not connected)
            logger.error('%s: network down', self)
            self.connect()
            ans = reply_with(request, SERVFAIL)
            dns = dnslib.DNSRecord.parse(ans)
            break
          else:
            raise
        finally:
          e = time.time()
    finally:
      if do_record:
        if dns and dns.header.rcode == SERVFAIL:
          logger.warn('%s: server failed', self)
          self.failed_times += 1
        self.record_time(e-s)

    return ans, dns

  @asyncio.coroutine
  def recv_answer(self, req):
    fu = asyncio.Future(loop=self.loop)
    id = req.header.id
    self._id_dict[id] = fu
    try:
      return (yield from fu)
    finally:
      try:
        del self._id_dict[id]
      except KeyError:
        pass

  def on_answer(self):
    co = self.handle_response()
    fu = asyncio.async(co, loop=self.loop)
    fu.add_done_callback(lambda fu: fu.result())

  @asyncio.coroutine
  def handle_response(self):
    ans = yield from self.recv_data()
    # recv_data (sock_recv) will overwrite the reader
    self.watch_answers()
    dns = dnslib.DNSRecord.parse(ans)

    try:
      fu = self._id_dict[dns.header.id]
    except KeyError:
      # drop unexpected answers
      logger.warn('%s: dropping not-requested ans:\n%s', self, dns)
      return

    for f in self.filters:
      action = f(dns)
      if action == 'skip':
        logger.warn('%s: skipping filtered answer:\n%s', self, dns.rr)
        return
      elif action == 'switch':
        logger.warn('%s: bad IP. switching to secondary_upstreams.', self)
        fu.set_exception(SwitchServer('IP is poisoned'))
        return
    fu.set_result((ans, dns))

  def log_stat(self):
    logger.info('%s: count/avg/mdev/failed: %d/%.1f/%.1f/%d',
                self,
                self._stat.n, self._stat.avg, self._stat.mdev,
                self.failed_times)

class UDPDNSClient(DNSClient):
  def prepare_request(self, request):
    return request.pack()

  @asyncio.coroutine
  def recv_data(self):
    ans = yield from self.loop.sock_recv(self.sock, 2048)
    return ans

class TCPDNSClient(DNSClient):
  def prepare_request(self, request):
    return struct.pack('!H', len(request)) + request.pack()

  @asyncio.coroutine
  def recv_data(self):
    s = self.sock
    header = yield from recv_exactly(s, 2)
    n = struct.unpack('!H', header)[0]
    ans = yield from recv_exactly(s, n)
    return ans

def show_stats(signo, frame):
  for client in chain(servers,
    config['primary_upstreams'], config['secondary_upstreams']):
    client.log_stat()

def main():
  try:
    import setproctitle
    setproctitle.setproctitle('cleandnsd')
    del setproctitle
  except ImportError:
    pass

  global servers
  loop = asyncio.get_event_loop()
  servers = [
    UDPDNSServer(
      s, config['primary_upstreams'], config['secondary_upstreams'],
      primary_timeout = config['primary_timeout'],
      secondary_timeout = config['secondary_timeout'],
      concurrent_delay = config['concurrent_delay'],
    ) for s in config['servers']]
  signal.signal(signal.SIGUSR1, show_stats)
  logging.info('serving on %r.', config['servers'])
  i = config['bogus_nxdomain_check_interval']
  asyncio.async(get_bogus_nxdomain(i))
  loop.run_forever()

if __name__ == '__main__':
  logging.getLogger('asyncio').setLevel(logging.WARN)
  config_logging(level=logging.DEBUG)
  # TODO: read config from command line
  # TODO: parse config file
  config = {
    'servers': [('127.0.0.1', 5353), ('::1', 5353)],
    'primary_upstreams': [DNSClient(('218.104.111.114', 53))],
    'secondary_upstreams': [DNSClient(('8.8.8.8', 53))],
    'primary_timeout': 5,
    'secondary_timeout': 5,
    'bogus_nxdomain_check_interval': 7200, # every two hour
    'filtered_ips': {
      '159.106.121.75', '159.24.3.173', '202.106.1.2', '202.181.7.85',
      '203.161.230.171', '203.98.7.65', '209.145.54.50', '216.234.179.13',
      '243.185.187.39', '37.61.54.158', '4.36.66.178', '46.82.174.68',
      '59.24.3.173', '64.33.88.161', '78.16.49.15', '8.7.198.45',
      '93.46.8.89',
    },
    'bogus_ips': set(),
    'concurrent_delay': 0.15,
  }
  try:
    main()
  except KeyboardInterrupt:
    pass
