#!/usr/bin/env python3

import sys
import os
import base64
import logging
import asyncio
import socket
import ipaddress
from functools import partial
import struct

import dnslib

logger = logging.getLogger('cleandnsd')
# TODO: handle truncated reply

class SwitchServer(Exception): pass
class NextServer(Exception): pass

def config_logging(level=logging.WARN, style=None):
  '''
  ``style``: terminal or plain
  '''
  if style is None:
    if os.isatty(sys.stderr.fileno()):
      style = 'terminal'
    else:
      style = 'plain'

  if style == 'plain':
    logging.basicConfig(
      level=level,
      format='%(levelname)s: %(message)s',
    )
  elif style == 'terminal':
    try:
      from nicelogger import enable_pretty_logging
      enable_pretty_logging(level)
    except ImportError:
      logging.basicConfig(
        level=level,
        format='%(asctime) s%(levelname)s: %(message)s',
        datefmt='[%Y-%m-%d %H:%M:%S]',
      )
  else:
    raise ValueError('bad logging style %r' % style)

def ip_family(ip):
  a = ipaddress.ip_address(ip)
  if a.version == 4:
    return socket.AF_INET
  elif a.version == 6:
    return socket.AF_INET6
  else:
    raise ValueError('unsupport IP address: %r', a)

@asyncio.coroutine
def recv_exactly(sock, n, *, loop=None):
  loop = loop or asyncio.get_event_loop()
  data = b''
  left = n
  while left:
    d = yield from loop.sock_recv(sock, left)
    if not d:
      raise ConnectionClosedError
    data += d
    left -= len(d)
  return data

def filter_badip(dns):
  if isinstance(dns.a.rdata, dnslib.A) and \
     str(dns.a.rdata) in config['filtered_ips']:
    return 'skip'

def filter_badip_switch(dns):
  r = filter_badip(dns)
  if r == 'skip':
    r = 'switch'
  return r

def is_bogus_nxdomain(dns):
  if isinstance(dns.a.rdata, dnslib.A) and \
     str(dns.a.rdata) in config['bogus_ips']:
    return True

# TODO: do it regularly
@asyncio.coroutine
def get_bogus_nxdomain():
  r = base64.b64encode(os.urandom(24)).decode('ascii')
  nxdomain = r.replace('/', '').replace('+', '') + '.com'
  req = dnslib.DNSRecord.question(nxdomain)
  for client in config['primary_upstreams']:
    ans, parsed = yield from client.query(req)
    if isinstance(parsed.a.rdata, dnslib.A):
      ip = str(parsed.a.rdata)
      logger.info('got bogus nxdomain: %s', ip)
      config['bogus_ips'].add(ip)
    else:
      logger.debug('no bogus nxdomain found:\n%s', parsed)

class ConnectionClosedError(ConnectionError):
  pass

class DNSCommon:
  sock = None

  def __repr__(self):
    return '<%s [%s]>' % (
      self.__class__.__name__,
      self.format_address(),
    )

  def format_address(self):
    return '%s:%s:%d' % (
      'TCP' if self.type is socket.SOCK_STREAM else 'UDP',
      self.address[0], self.address[1])

  def __del__(self):
    self.close()

  def close(self):
    if self.sock:
      self.loop.remove_reader(self.sock.fileno())
      self.sock.close()
      self.sock = None

class UDPDNSServer(DNSCommon):
  sock = None
  type = socket.SOCK_DGRAM

  def __init__(self, address,
               primary_upstreams, secondary_upstreams,
               *, loop=None):
    self.address = address
    self.primary_upstreams = primary_upstreams
    self.secondary_upstreams = secondary_upstreams
    self.loop = loop = loop or asyncio.get_event_loop()

    self.sock = s = socket.socket(
      ip_family(address[0]), socket.SOCK_DGRAM)
    s.setblocking(False)
    s.bind(address)

    loop.add_reader(s.fileno(), self.on_request)

  def on_request(self):
    co = self.handle_request()
    asyncio.Task(co, loop=self.loop)

  @asyncio.coroutine
  def handle_request(self):
    s = self.sock
    try:
      data, addr = s.recvfrom(2048)
    except BlockingIOError:
      return

    request = dnslib.DNSRecord.parse(data)
    logger.info('%r request record %s of %s', addr,
                dnslib.QTYPE[request.q.qtype], request.q.qname)

    try:
      ans, parsed = yield from \
          config['primary_upstreams'][0].query(request)
    except SwitchServer:
      ans, parsed = yield from \
          config['secondary_upstreams'][0].query(request)
    except NextServer:
      # TODO multiple servers
      logger.warn('%s: should try next server', self)

    if is_bogus_nxdomain(parsed):
      logger.warn('%s: bogus nxdomain, sending back nxdomain to %r',
                  self, addr)
      ans = request.reply()
      ans.header.rcode = dnslib.RCODE.NXDOMAIN
      ans = ans.pack()
    else:
      logger.debug('%s: sending back DNS answer to %r:\n%s (%s): %s', self, addr,
                   parsed.q.qname, dnslib.QTYPE[parsed.q.qtype], parsed.rr)
    s.sendto(ans, addr)

class DNSClient(DNSCommon):
  sock = None
  connecting = None
  filters = ()
  timeout = 3

  def __new__(cls, address, type=socket.SOCK_DGRAM,
              *, loop=None):
    if type is socket.SOCK_DGRAM:
      C = UDPDNSClient
    else:
      C = TCPDNSClient

    instance = super().__new__(C)
    return instance

  def __init__(self, address, type=socket.SOCK_DGRAM,
               *, loop=None):
    self.loop = loop or asyncio.get_event_loop()
    self.address = address
    self.type = type
    self._id_dict = {}
    self.connect()

  def connect(self):
    self.close()
    self.sock = socket.socket(ip_family(self.address[0]), self.type)
    self.sock.setblocking(False)
    self.connecting = self.loop.sock_connect(self.sock, self.address)
    self.connecting.add_done_callback(self.connected)

  def connected(self, fu):
    fu.result()
    self.connecting = None
    logger.info('%s: connected', self)
    self.watch_answers()

  def watch_answers(self):
    self.loop.add_reader(self.sock.fileno(), self.on_answer)

  @asyncio.coroutine
  def query(self, request):
    if self.connecting:
      yield from self.connecting
      self.connecting = None

    data = self.prepare_request(request)

    for i in range(3):
      try:
        yield from self.loop.sock_sendall(self.sock, data)
        ans, dns = yield from self.recv_answer(request)
        break
      except ConnectionError:
        logger.warn('%s: connection error, reconnecting', self, exc_info=True)
        self.connect()
      except TimeoutError:
        logger.warn('%s: request timeout', self)
    else:
      raise NextServer('this server is bad')

    return ans, dns

  @asyncio.coroutine
  def recv_answer(self, req):
    loop = self.loop
    fu = asyncio.Future(loop=loop)
    id = req.header.id
    self._id_dict[id] = fu
    try:
      yield from asyncio.wait_for(fu, self.timeout, loop=loop)
      return fu.result()
    finally:
      del self._id_dict[id]

  def on_answer(self):
    co = self.handle_response()
    asyncio.Task(co, loop=self.loop)

  @asyncio.coroutine
  def handle_response(self):
    ans = yield from self.recv_data()
    # recv_data (sock_recv) will overwrite the reader
    self.watch_answers()
    dns = dnslib.DNSRecord.parse(ans)

    try:
      fu = self._id_dict[dns.header.id]
    except KeyError:
      # drop unexpected answers
      logger.warn('%s: dropping not-requested ans:\n%s', self, dns)
      return

    for f in self.filters:
      action = f(dns)
      if action == 'skip':
        logger.warn('%s: skipping filtered answer:\n%s', self, dns.rr)
        return
      elif action == 'switch':
        logger.warn('%s: bad IP. switching to secondary_upstreams.', self)
        fu.set_exception(SwitchServer('IP is poisoned'))
        return
    fu.set_result((ans, dns))

class UDPDNSClient(DNSClient):
  def prepare_request(self, request):
    return request.pack()

  @asyncio.coroutine
  def recv_data(self):
    ans = yield from self.loop.sock_recv(self.sock, 2048)
    return ans

class TCPDNSClient(DNSClient):
  def prepare_request(self, request):
    return struct.pack('!H', len(request)) + request.pack()

  @asyncio.coroutine
  def recv_data(self):
    s = self.sock
    header = yield from recv_exactly(s, 2)
    n = struct.unpack('!H', header)[0]
    ans = yield from recv_exactly(s, n)
    return ans

def LocalDNSClient(*args, **kwargs):
  c = DNSClient(*args, **kwargs)
  c.filters = (filter_badip_switch,)
  c.timeout = local_timeout
  return c

def GlobalDNSClient(*args, **kwargs):
  c = DNSClient(*args, **kwargs)
  c.filters = (filter_badip,)
  c.timeout = global_timeout
  return c

def main():
  loop = asyncio.get_event_loop()
  servers = [
    UDPDNSServer(
      s, config['primary_upstreams'], config['secondary_upstreams'])
    for s in config['servers']]
  logging.info('serving on %r.', config['servers'])
  asyncio.async(get_bogus_nxdomain())
  loop.run_forever()

if __name__ == '__main__':
  logging.getLogger('asyncio').setLevel(logging.WARN)
  config_logging(level=logging.DEBUG)
  # TODO: read config from command line
  # TODO: parse config file
  local_timeout = 0.5
  global_timeout = 1
  config = {
    'servers': [('127.0.0.1', 5353), ('::1', 5353)],
    'primary_upstreams': [LocalDNSClient(('218.104.111.114', 53))],
    'secondary_upstreams': [GlobalDNSClient(('8.8.8.8', 53))],
    'filtered_ips': {
      '159.106.121.75', '159.24.3.173', '202.106.1.2', '202.181.7.85',
      '203.161.230.171', '203.98.7.65', '209.145.54.50', '216.234.179.13',
      '243.185.187.39', '37.61.54.158', '4.36.66.178', '46.82.174.68',
      '59.24.3.173', '64.33.88.161', '78.16.49.15', '8.7.198.45',
      '93.46.8.89',
    },
    'bogus_ips': set(),
    'query_method': 'failover', # or 'concurrent',
  }
  try:
    main()
  except KeyboardInterrupt:
    pass
