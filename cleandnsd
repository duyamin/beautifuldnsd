#!/usr/bin/env python3

import sys
import os
import base64
import logging
import asyncio
import socket
import ipaddress
from functools import partial
from itertools import chain
import struct
import time

import dnslib

from stats import Stat

logger = logging.getLogger('cleandnsd')
# TODO: handle truncated reply

class SwitchServer(Exception): pass
class NextServer(Exception): pass

def config_logging(level=logging.WARN, style=None):
  '''
  ``style``: terminal or plain
  '''
  if style is None:
    if os.isatty(sys.stderr.fileno()):
      style = 'terminal'
    else:
      style = 'plain'

  if style == 'plain':
    logging.basicConfig(
      level=level,
      format='%(levelname)s: %(message)s',
    )
  elif style == 'terminal':
    try:
      from nicelogger import enable_pretty_logging
      enable_pretty_logging(level)
    except ImportError:
      logging.basicConfig(
        level=level,
        format='%(asctime) s%(levelname)s: %(message)s',
        datefmt='[%Y-%m-%d %H:%M:%S]',
      )
  else:
    raise ValueError('bad logging style %r' % style)

def ip_family(ip):
  a = ipaddress.ip_address(ip)
  if a.version == 4:
    return socket.AF_INET
  elif a.version == 6:
    return socket.AF_INET6
  else:
    raise ValueError('unsupport IP address: %r', a)

@asyncio.coroutine
def recv_exactly(sock, n, *, loop=None):
  loop = loop or asyncio.get_event_loop()
  data = b''
  left = n
  while left:
    d = yield from loop.sock_recv(sock, left)
    if not d:
      raise ConnectionClosedError
    data += d
    left -= len(d)
  return data

def reply_with(request, rcode):
  ans = request.reply()
  ans.header.rcode = rcode
  return ans.pack()

def filter_badip(dns):
  if isinstance(dns.a.rdata, dnslib.A) and \
     str(dns.a.rdata) in config['filtered_ips']:
    return 'skip'

def filter_badip_switch(dns):
  r = filter_badip(dns)
  if r == 'skip':
    r = 'switch'
  return r

def is_bogus_nxdomain(dns):
  if isinstance(dns.a.rdata, dnslib.A) and \
     str(dns.a.rdata) in config['bogus_ips']:
    return True

# TODO: move into UDPDNSServer
@asyncio.coroutine
def get_bogus_nxdomain(interval):
  while True:
    r = base64.b64encode(os.urandom(24)).decode('ascii')
    nxdomain = r.replace('/', '').replace('+', '') + '.com'
    req = dnslib.DNSRecord.question(nxdomain)
    for client in config['primary_upstreams']:
      ans, parsed = yield from client.query(req)
      if isinstance(parsed.a.rdata, dnslib.A):
        ip = str(parsed.a.rdata)
        logger.info('got bogus nxdomain: %s', ip)
        config['bogus_ips'].add(ip)
      else:
        logger.debug('no bogus nxdomain found:\n%s', parsed)
    yield from asyncio.sleep(interval)

class ConnectionClosedError(ConnectionError):
  pass

class DNSCommon:
  sock = None

  def __repr__(self):
    return '<%s [%s]>' % (
      self.__class__.__name__,
      self.format_address(),
    )

  def format_address(self):
    return '%s:%s:%d' % (
      'TCP' if self.type is socket.SOCK_STREAM else 'UDP',
      self.address[0], self.address[1])

  def __del__(self):
    self.close()

  def close(self):
    if self.sock:
      self.loop.remove_reader(self.sock.fileno())
      self.sock.close()
      self.sock = None

class UDPDNSServer(DNSCommon):
  sock = None
  type = socket.SOCK_DGRAM

  def __init__(self, address,
               primary_upstreams, secondary_upstreams,
               *, loop=None,
               primary_timeout = 3,
               secondary_timeout = 3):
    self.address = address
    self.loop = loop = loop or asyncio.get_event_loop()
    self.primary_upstreams = primary_upstreams
    self.secondary_upstreams = secondary_upstreams
    for c in primary_upstreams:
      c.filters = (filter_badip_switch,)
      c.timeout = primary_timeout
    for c in secondary_upstreams:
      c.filters = (filter_badip,)
      c.timeout = secondary_timeout

    self.sock = s = socket.socket(
      ip_family(address[0]), socket.SOCK_DGRAM)
    s.setblocking(False)
    s.bind(address)

    loop.add_reader(s.fileno(), self.on_request)

  def on_request(self):
    co = self.handle_request()
    fu = asyncio.Task(co, loop=self.loop)
    fu.add_done_callback(lambda fu: fu.result())

  @asyncio.coroutine
  def handle_request(self):
    s = self.sock
    try:
      data, addr = s.recvfrom(2048)
    except BlockingIOError:
      return

    request = dnslib.DNSRecord.parse(data)
    logger.info('%r request record %s of %s', addr,
                dnslib.QTYPE[request.q.qtype], request.q.qname)

    failed = False
    it = chain(self.primary_upstreams, self.secondary_upstreams)
    try:
      while True:
        server = next(it)
        logger.debug('%s: trying server %s', self, server)
        try:
          ans, parsed = yield from server.query(request)
          break
        except SwitchServer:
          it = iter(self.secondary_upstreams)
        except NextServer:
          logger.debug('%s: bad server %s. trying next server',
                       self, server)
    except StopIteration:
      failed = True

    if failed:
      logger.warn('%s: all servers failed to reply', self)
      ans = reply_with(request, dnslib.RCODE.SERVFAIL)
    elif is_bogus_nxdomain(parsed):
      logger.warn('%s: bogus nxdomain, sending back nxdomain to %r',
                  self, addr)
      ans = reply_with(request, dnslib.RCODE.NXDOMAIN)
    else:
      logger.debug('%s: sending back DNS answer to %r:\n%s (%s): %s',
                   self, addr,
                   parsed.q.qname, dnslib.QTYPE[parsed.q.qtype], parsed.rr)

    s.sendto(ans, addr)

class DNSClient(DNSCommon):
  sock = None
  connecting = None
  filters = ()
  timeout = 3

  def __new__(cls, address, type=socket.SOCK_DGRAM,
              *, loop=None):
    if type is socket.SOCK_DGRAM:
      C = UDPDNSClient
    else:
      C = TCPDNSClient

    instance = super().__new__(C)
    return instance

  def __init__(self, address, type=socket.SOCK_DGRAM,
               *, loop=None):
    self.loop = loop or asyncio.get_event_loop()
    self.address = address
    self.type = type
    self._id_dict = {}
    self._stat = Stat()
    self.connect()

  def connect(self):
    self.close()
    self.sock = socket.socket(ip_family(self.address[0]), self.type)
    self.sock.setblocking(False)
    self.connecting = self.loop.sock_connect(self.sock, self.address)
    self.connecting.add_done_callback(self.connected)

  def connected(self, fu):
    self.connecting = None
    try:
      fu.result()
    except OSError as e:
      if e.errno == 101: # Network is unreachable
        logger.error('%s: Network is unreachable', self)
        return
      else:
        raise
    logger.info('%s: connected', self)
    self.watch_answers()

  def watch_answers(self):
    self.loop.add_reader(self.sock.fileno(), self.on_answer)

  @asyncio.coroutine
  def query(self, request):
    if self.connecting:
      yield from self.connecting

    data = self.prepare_request(request)

    while True:
      try:
        yield from self.loop.sock_sendall(self.sock, data)
        s = time.time()
        ans, dns = yield from self.recv_answer(request)
        e = time.time()
        self.record_time(e-s)
        break
      except ConnectionError:
        logger.warn('%s: connection error, reconnecting', self, exc_info=True)
        self.connect()
      except asyncio.TimeoutError:
        logger.warn('%s: request for %s timeout', self, request.q.qname)
        raise NextServer('this server is bad')
      except OSError as e:
        if e.errno in (22, 89):
          # 22: Invalid argument
          # 89: Destination address required (not connected)
          logger.error('%s: network down', self)
          self.connect()
          ans = reply_with(request, dnslib.RCODE.SERVFAIL)
          dns = dnslib.DNSRecord.parse(ans)
          break
        else:
          raise

    return ans, dns

  @asyncio.coroutine
  def recv_answer(self, req):
    loop = self.loop
    fu = asyncio.Future(loop=loop)
    id = req.header.id
    self._id_dict[id] = fu
    try:
      yield from asyncio.wait_for(fu, self.timeout, loop=loop)
      return fu.result()
    finally:
      del self._id_dict[id]

  def on_answer(self):
    co = self.handle_response()
    fu = asyncio.Task(co, loop=self.loop)
    fu.add_done_callback(lambda fu: fu.result())

  @asyncio.coroutine
  def handle_response(self):
    ans = yield from self.recv_data()
    # recv_data (sock_recv) will overwrite the reader
    self.watch_answers()
    dns = dnslib.DNSRecord.parse(ans)

    try:
      fu = self._id_dict[dns.header.id]
    except KeyError:
      # drop unexpected answers
      logger.warn('%s: dropping not-requested ans:\n%s', self, dns)
      return

    for f in self.filters:
      action = f(dns)
      if action == 'skip':
        logger.warn('%s: skipping filtered answer:\n%s', self, dns.rr)
        return
      elif action == 'switch':
        logger.warn('%s: bad IP. switching to secondary_upstreams.', self)
        fu.set_exception(SwitchServer('IP is poisoned'))
        return
    fu.set_result((ans, dns))

  def record_time(self, t):
    self._stat.add(t * 1000)

  def __repr__(self):
    try:
      return '<%s [%s] (count/avg/mdev: %d/%.1f/%.1f)>' % (
        self.__class__.__name__,
        self.format_address(),
        self._stat.n,
        self._stat.avg,
        self._stat.mdev,
      )
    except:
      return super().__repr__()

class UDPDNSClient(DNSClient):
  def prepare_request(self, request):
    return request.pack()

  @asyncio.coroutine
  def recv_data(self):
    ans = yield from self.loop.sock_recv(self.sock, 2048)
    return ans

class TCPDNSClient(DNSClient):
  def prepare_request(self, request):
    return struct.pack('!H', len(request)) + request.pack()

  @asyncio.coroutine
  def recv_data(self):
    s = self.sock
    header = yield from recv_exactly(s, 2)
    n = struct.unpack('!H', header)[0]
    ans = yield from recv_exactly(s, n)
    return ans

def main():
  loop = asyncio.get_event_loop()
  servers = [
    UDPDNSServer(
      s, config['primary_upstreams'], config['secondary_upstreams'],
      primary_timeout = config['primary_timeout'],
      secondary_timeout = config['secondary_timeout'],
    ) for s in config['servers']]
  logging.info('serving on %r.', config['servers'])
  i = config['bogus_nxdomain_check_interval']
  asyncio.async(get_bogus_nxdomain(i))
  loop.run_forever()

if __name__ == '__main__':
  logging.getLogger('asyncio').setLevel(logging.WARN)
  config_logging(level=logging.DEBUG)
  # TODO: read config from command line
  # TODO: parse config file
  config = {
    'servers': [('127.0.0.1', 5353), ('::1', 5353)],
    'primary_upstreams': [DNSClient(('218.104.111.114', 53))],
    'secondary_upstreams': [DNSClient(('8.8.8.8', 53))],
    'primary_timeout': 1,
    'secondary_timeout': 3,
    'bogus_nxdomain_check_interval': 7200, # every two hour
    'filtered_ips': {
      '159.106.121.75', '159.24.3.173', '202.106.1.2', '202.181.7.85',
      '203.161.230.171', '203.98.7.65', '209.145.54.50', '216.234.179.13',
      '243.185.187.39', '37.61.54.158', '4.36.66.178', '46.82.174.68',
      '59.24.3.173', '64.33.88.161', '78.16.49.15', '8.7.198.45',
      '93.46.8.89',
    },
    'bogus_ips': set(),
    # TODO: implemenet this
    'query_method': 'failover', # or 'concurrent',
  }
  try:
    main()
  except KeyboardInterrupt:
    pass
