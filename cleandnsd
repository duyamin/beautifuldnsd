#!/usr/bin/env python3

import sys
import os
import base64
import logging
import asyncio
import socket
import ipaddress
from functools import partial
import struct

import dnslib

logger = logging.getLogger('cleandnsd')

class SwitchServer(Exception): pass

def config_logging(level=logging.WARN, style=None):
  '''
  ``style``: terminal or plain
  '''
  if style is None:
    if os.isatty(sys.stderr.fileno()):
      style = 'terminal'
    else:
      style = 'plain'

  if style == 'plain':
    logging.basicConfig(
      level=level,
      format='%(levelname)s: %(message)s',
    )
  elif style == 'terminal':
    try:
      from nicelogger import enable_pretty_logging
      enable_pretty_logging(level)
    except ImportError:
      logging.basicConfig(
        level=level,
        format='%(asctime) s%(levelname)s: %(message)s',
        datefmt='[%Y-%m-%d %H:%M:%S]',
      )
  else:
    raise ValueError('bad logging style %r' % style)

def ip_family(ip):
  a = ipaddress.ip_address(ip)
  if a.version == 4:
    return socket.AF_INET
  elif a.version == 6:
    return socket.AF_INET6
  else:
    raise ValueError('unsupport IP address: %r', a)

@asyncio.coroutine
def recv_exactly(sock, n, *, loop=None):
  loop = loop or asyncio.get_event_loop()
  data = b''
  left = n
  while left:
    d = yield from loop.sock_recv(sock, left)
    if not d:
      raise ConnectionClosedError
    data += d
    left -= len(d)
  return data

def filter_badip(dns):
  if isinstance(dns.a.rdata, dnslib.A) and \
     str(dns.a.rdata) in config['filtered_ips']:
    return True

def is_bogus_nxdomain(dns):
  if isinstance(dns.a.rdata, dnslib.A) and \
     str(dns.a.rdata) in config['bogus_ips']:
    return True

# TODO: do it regularly
@asyncio.coroutine
def get_bogus_nxdomain():
  r = base64.b64encode(os.urandom(24)).decode('ascii')
  nxdomain = r.replace('/', '').replace('+', '') + '.com'
  req = dnslib.DNSRecord.question(nxdomain).pack()
  for client in config['primary_upstreams']:
    ans, parsed = yield from client.query(req)
    if isinstance(parsed.a.rdata, dnslib.A):
      ip = str(parsed.a.rdata)
      logger.info('got bogus nxdomain: %s', ip)
      config['bogus_ips'].add(ip)
    else:
      logger.debug('no bogus nxdomain found:\n%s', parsed)

class ConnectionClosedError(ConnectionError):
  pass

class DNSCommon:
  def __repr__(self):
    return '<%s [%s]>' % (
      self.__class__.__name__,
      self.format_address(),
    )

  def format_address(self):
    return '%s:%s:%d' % (
      'TCP' if self.type is socket.SOCK_STREAM else 'UDP',
      self.address[0], self.address[1])

  def __del__(self):
    self.close()

class UDPDNSServer(DNSCommon):
  sock = None
  type = socket.SOCK_DGRAM

  def __init__(self, address,
               primary_upstreams, secondary_upstreams,
               *, loop=None):
    self.address = address
    self.primary_upstreams = primary_upstreams
    self.secondary_upstreams = secondary_upstreams
    self.loop = loop = loop or asyncio.get_event_loop()

    self.sock = s = socket.socket(
      ip_family(address[0]), socket.SOCK_DGRAM)
    s.setblocking(False)
    s.bind(address)

    loop.add_reader(s.fileno(), self.on_request)

  def on_request(self):
    co = self.handle_request()
    asyncio.Task(co, loop=self.loop)

  @asyncio.coroutine
  def handle_request(self):
    s = self.sock
    try:
      data, addr = s.recvfrom(2048)
    except BlockingIOError:
      return

    request = dnslib.DNSRecord.parse(data)
    logger.info('%r request record %s of %s', addr,
                dnslib.QTYPE[request.q.qtype], request.q.qname)

    # TODO multiple servers
    try:
      ans, parsed = yield from config['primary_upstreams'][0].query(
        data, filters=(filter_badip,), on_filtered='switch')
    except SwitchServer:
      ans, parsed = yield from config['secondary_upstreams'][0].query(
        data, filters=(filter_badip,))

    if is_bogus_nxdomain(parsed):
      logger.warn('%s: bogus nxdomain, sending back nxdomain to %r',
                  self, addr)
      ans = request.reply()
      ans.header.rcode = dnslib.RCODE.NXDOMAIN
      ans = ans.pack()
    else:
      logger.debug('%s: sending back DNS answer to %r:\n%s (%s): %s', self, addr,
                   parsed.q.qname, dnslib.QTYPE[parsed.q.qtype], parsed.rr)
    s.sendto(ans, addr)

  def close(self):
    if self.sock:
      self.loop.remove_reader(self.sock.fileno())
      self.sock.close()
      self.sock = None

class DNSClient(DNSCommon):
  sock = None
  connecting = None

  def __new__(cls, address, type=socket.SOCK_DGRAM,
              *, loop=None):
    if type is socket.SOCK_DGRAM:
      C = UDPDNSClient
    else:
      C = TCPDNSClient

    instance = super().__new__(C)
    return instance

  def __init__(self, address, type=socket.SOCK_DGRAM,
               *, loop=None):
    self.loop = loop or asyncio.get_event_loop()
    self.address = address
    self.type = type
    self.connect()

  def connect(self):
    self.close()
    self.sock = socket.socket(ip_family(self.address[0]), self.type)
    self.sock.setblocking(False)
    self.connecting = self.loop.sock_connect(self.sock, self.address)
    self.connecting.add_done_callback(self.connected)

  def connected(self, fu):
    fu.result()
    self.connecting = None
    logger.info('%s: connected', self)

  def close(self):
    if self.sock:
      self.sock.close()
      self.sock = None

  @asyncio.coroutine
  def query(self, request, filters=(), on_filtered='skip'):
    if self.connecting:
      yield from self.connecting
      self.connecting = None

    # TODO: timeout handling
    # TODO: match dns.header.id
    data = self.prepare_request(request)

    try:
      yield from self.loop.sock_sendall(self.sock, data)
      while True:
        skip = False
        ans = yield from self.recv_data()
        dns = dnslib.DNSRecord.parse(ans)
        for f in filters:
          if f(dns):
            if on_filtered == 'skip':
              logger.warn('%s: skipping filtered answer:\n%s', self, dns.rr)
              skip = True
            elif on_filtered == 'switch':
              logger.warn('%s: bad IP. switching to secondary_upstreams.', self)
              raise SwitchServer('IP is poisoned')
        if not skip:
          break
    except ConnectionError:
      # FIXME: don't retry too many times
      logger.warn('%s: connection error, reconnecting', self, exc_info=True)
      self.connect()
      ans, dns = yield from self.query(request, filters)

    return ans, dns

class UDPDNSClient(DNSClient):
  def prepare_request(self, request):
    return request

  @asyncio.coroutine
  def recv_data(self):
    ans = yield from self.loop.sock_recv(self.sock, 2048)
    return ans

class TCPDNSClient(DNSClient):
  def prepare_request(self, request):
    return struct.pack('!H', len(request)) + request

  @asyncio.coroutine
  def recv_data(self):
    s = self.sock
    header = yield from recv_exactly(s, 2)
    n = struct.unpack('!H', header)[0]
    ans = yield from recv_exactly(s, n)
    return ans

def main():
  loop = asyncio.get_event_loop()
  servers = [
    UDPDNSServer(
      s, config['primary_upstreams'], config['secondary_upstreams'])
    for s in config['servers']]
  logging.info('serving on %r.', config['servers'])
  asyncio.async(get_bogus_nxdomain())
  loop.run_forever()

if __name__ == '__main__':
  logging.getLogger('asyncio').setLevel(logging.WARN)
  config_logging(level=logging.DEBUG)
  # TODO: read config from command line
  # TODO: parse config file
  config = {
    'servers': [('127.0.0.1', 5353), ('::1', 5353)],
    # 'primary_upstreams': [DNSClient(('127.0.0.1', 53))],
    'primary_upstreams': [DNSClient(('218.104.111.114', 53))],
    'secondary_upstreams': [DNSClient(('8.8.8.8', 53))],
    # 'primary_upstreams': [DNSClient(('8.8.8.8', 53))],
    # 'primary_upstreams': [DNSClient(('8.8.8.8', 53), socket.SOCK_STREAM)],
    'filtered_ips': {
      '159.106.121.75', '159.24.3.173', '202.106.1.2', '202.181.7.85',
      '203.161.230.171', '203.98.7.65', '209.145.54.50', '216.234.179.13',
      '243.185.187.39', '37.61.54.158', '4.36.66.178', '46.82.174.68',
      '59.24.3.173', '64.33.88.161', '78.16.49.15', '8.7.198.45',
      '93.46.8.89',
    },
    'bogus_ips': set(),
    'query_method': 'failover', # or 'concurrent',
  }
  try:
    main()
  except KeyboardInterrupt:
    pass
